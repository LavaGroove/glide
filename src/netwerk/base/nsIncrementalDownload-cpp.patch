diff --git a/netwerk/base/nsIncrementalDownload.cpp b/netwerk/base/nsIncrementalDownload.cpp
index 03644f8a1891b0cf18f65d072954ef813f0c1641..1fcc5e96e159901dd5c42963385e6d4f44fe9264 100644
--- a/netwerk/base/nsIncrementalDownload.cpp
+++ b/netwerk/base/nsIncrementalDownload.cpp
@@ -150,6 +150,7 @@ class nsIncrementalDownload final : public nsIIncrementalDownload,
   nsCString mPartialValidator;
   bool mCacheBust{false};
   nsCString mExtraHeaders;
+  bool mExtraHeadersMerge{true};
 
   // nsITimerCallback is implemented on a subclass so that the name attribute
   // doesn't conflict with the name attribute of the nsIRequest interface.
@@ -250,7 +251,7 @@ nsresult nsIncrementalDownload::ProcessTimeout() {
   if (NS_FAILED(rv)) return rv;
 
   if (!mExtraHeaders.IsEmpty()) {
-    rv = AddExtraHeaders(http, mExtraHeaders);
+    rv = AddExtraHeaders(http, mExtraHeaders, mExtraHeadersMerge);
     if (NS_FAILED(rv)) return rv;
   }
 
@@ -437,6 +438,21 @@ nsIncrementalDownload::Init(nsIURI* uri, nsIFile* dest, int32_t chunkSize,
 
   mExtraHeaders = extraHeaders;
 
+  // tmp: while our repo is private we have to fetch update assets through the
+  //      github API, which requires a specific content-type header and the
+  //      default behaviour of `mExtraHeaders` is to merge with the existing
+  //      headers, so we need to overwrite that.
+  nsAutoCString host;
+  nsresult rv = uri->GetHost(host);
+  if (!NS_FAILED(rv) && host.EqualsLiteral("api.github.com")) {
+    nsAutoCString path;
+    rv = uri->GetPathQueryRef(path);
+    if (!NS_FAILED(rv) &&
+        path.Find("/repos/glide-browser/glide/releases/assets/") == 0) {
+      mExtraHeadersMerge = false;
+    }
+  }
+
   return NS_OK;
 }
 
@@ -853,7 +869,7 @@ nsIncrementalDownload::AsyncOnChannelRedirect(
   if (NS_FAILED(rv)) return rv;
 
   if (!mExtraHeaders.IsEmpty()) {
-    rv = AddExtraHeaders(http, mExtraHeaders);
+    rv = AddExtraHeaders(http, mExtraHeaders, mExtraHeadersMerge);
     if (NS_FAILED(rv)) return rv;
   }
 
