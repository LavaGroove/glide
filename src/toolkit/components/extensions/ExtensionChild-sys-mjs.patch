diff --git a/toolkit/components/extensions/ExtensionChild.sys.mjs b/toolkit/components/extensions/ExtensionChild.sys.mjs
index 27dc8a50e9fc683fbd2b5f923d7f1944b7d81959..8e3cd568dace992bc04a24d41f3b0cff3ef3e8fe 100644
--- a/toolkit/components/extensions/ExtensionChild.sys.mjs
+++ b/toolkit/components/extensions/ExtensionChild.sys.mjs
@@ -28,6 +28,15 @@ const lazy = XPCOMUtils.declareLazy({
   },
 });
 
+/** @type {typeof import("../../../glide/browser/base/content/utils/ipc.mts")} **/
+const { deserialise_args } = ChromeUtils.importESModule(
+  "chrome://glide/content/utils/ipc.mjs"
+);
+/** @type {typeof import("../../../glide/browser/base/content/sandbox.mts")} **/
+const { create_sandbox } = ChromeUtils.importESModule(
+  "chrome://glide/content/sandbox.mjs"
+);
+
 import { ExtensionCommon } from "resource://gre/modules/ExtensionCommon.sys.mjs";
 import { ExtensionUtils } from "resource://gre/modules/ExtensionUtils.sys.mjs";
 
@@ -882,6 +891,67 @@ export class ChildAPIManager {
         return result;
       });
     }
+
+    // glide-injection-start
+    //
+    // Adds a handler for a custom path so that the parent actor can invoke arbitrary
+    // methods on the `browser` variable from within the correct extension context.
+    //
+    // This is used to power the `browser` variable inside the glide config file.
+    //
+    // Note that this code path is *not* hit when adding event listeners, e.g.
+    // `browser.tabs.onMoved.addListener(() => ...)`, instead we just use the
+    // `browserObj` from the parent context directly as we'd have to serialize
+    // the given function and the Web Extensions API does not provide a way to
+    // pass arguments through in this case as it's not needed under a typical
+    // setup.
+    //
+    // TODO(glide): just register this inside the extension instead of
+    //              hard-coding it here.
+    if (data.path && data.path === "glide.invoke_browser") {
+      const args = data.args.deserialize(this.context.cloneScope);
+      const method_args = args.slice(1);
+
+      const method_path = args[0];
+      if (!method_path) {
+        throw new Error(
+          "Expected `glide.invoke_browser` message to define a method name argument, e.g. `['tabs.create']`"
+        );
+      }
+
+      let method = this.context.browserObj;
+      for (const prop of method_path.split(".")) {
+        method = method[prop];
+        if (method == null) {
+          throw new Error(
+            `Could not resolve \`browser\` property at path \`${method_path}\` - \`${prop}\` was not defined`
+          );
+        }
+      }
+
+      const sandbox = create_sandbox({
+        document: this.context.contentWindow.document,
+        window: this.context.contentWindow,
+        browser: this.context.browserObj,
+        console,
+        glide: null,
+      });
+
+      const args_deser = deserialise_args(sandbox, method_args);
+
+      return Promise.resolve(method(...args_deser)).then(result => {
+        if (result !== undefined) {
+          return new StructuredCloneHolder(
+            `ChildAPIManager/${this.context.extension.id}/${data.path}`,
+            null,
+            result,
+            this.context.cloneScope
+          );
+        }
+        return result;
+      });
+    }
+
     if (!map.removedIds.has(data.listenerId)) {
       Services.console.logStringMessage(
         `Unknown listener at childId=${data.childId} path=${data.path} listenerId=${data.listenerId}\n`
