diff --git a/toolkit/components/extensions/ExtensionCommon.sys.mjs b/toolkit/components/extensions/ExtensionCommon.sys.mjs
index 58fb93a61d302d25f75fb2cfb195411e528eb6a4..8657542c78a7f86a367dcee9192c59e82d0991b1 100644
--- a/toolkit/components/extensions/ExtensionCommon.sys.mjs
+++ b/toolkit/components/extensions/ExtensionCommon.sys.mjs
@@ -697,6 +697,14 @@ export class BaseContext {
           Reflect.apply(callback, null, args)
         );
       } catch (e) {
+        if (this.extension.id === "glide-internal@mozilla.org") {
+          // store any errors that happen when invoking one of the listeners
+          // registered in the config so that the browser code can pick it up
+          // and report the error
+          this.$glide_errors ??= new Set();
+          this.$glide_errors.add({ error: e, source: "applySafeWithoutClone" });
+        }
+
         if (this.isProxyContextParent) {
           Cu.reportError(e);
         }
@@ -2760,6 +2768,25 @@ class EventManager {
     EventManager._writePersistentListeners(extension);
   }
 
+  _callAndRecordGlideError(callback, thisArgument, args) {
+    try {
+      return Reflect.apply(callback, thisArgument, args);
+    } catch (error) {
+      if (this.context?.extension?.id === "glide-internal@mozilla.org") {
+        // store any errors that happen when invoking one of the listeners
+        // registered in the config so that the browser code can pick it up
+        // and report the error
+        this.context.$glide_errors ??= new Set();
+        this.context.$glide_errors.add({
+          error,
+          source: "_callAndRecordGlideError",
+        });
+      }
+
+      throw error;
+    }
+  }
+
   addListener(callback, ...args) {
     if (this.unregister.has(callback)) {
       return;
@@ -2819,12 +2846,12 @@ class EventManager {
           this.context.isProxyContextParent ||
           lazy.callFunctionAndLogExceptionDisabled
         ) {
-          result = Reflect.apply(callback, null, args);
+          result = this._callAndRecordGlideError(callback, null, args);
         } else {
           // Use callFunctionAndLogException in order to ensure routing any exception to DevTools.
           result = ChromeUtils.callFunctionAndLogException(
             this.context.cloneScope,
-            () => Reflect.apply(callback, null, args)
+            () => this._callAndRecordGlideError(callback, null, args)
           );
         }
         this.context.logActivity("api_event", this.name, { args, result });
